#Requires -Version 3

<#

    .NOTES  
    File Name    : AzureDemo-ProvisionVMsGlobally.ps1  
    Last Updated : May 26, 2015
    Version      : 0.91
    Author       : Ruud Borst  ruud@ruudborst.nl  
    Reviewer     : Darryl van der Peijl  darrylvanderpeijl@outlook.com
    Requires     : PowerShell V3, Azure PowerShell Module, Azure Subscription

    .LINK  

    http://www.ruudborst.nl
    
    .SYNOPSIS

    Rapid deploys an Azure Virtual Machine in every available Microsoft Azure Datacenter/Region. 

    .DESCRIPTION

    This script helps you to automatically deploy an Azure VM, Azure Service and related Storage Account in each available Microsoft Azure Datacenter.
    It also facilitates in the provisioning and management of these VM's through the script advanced functions which are made
    available in the 'Global' scope and thus can be used in the console. This includes the VM and storage account provisioning,
    remote powerShell session setup, powershell remote command execution, rdp connection and public endpoint functions.
    
    This way it's fairly easy to provision the VM's in every Azure region available, use the resources (network/compute/storage) 
    at that location and execute any remote ps commands to that VM. The 'Execute-RemoteCommand' facilitates in the session setup 
    and let's you execute a command against one or more VM's and orders all results accordingly.
    
    All script parameters are optional and will be determined automatically when left blank. In addition to the configurable 
    script parameters, the script's main routine will prompt for the administrator credentials, the Windows image file (deployment)
    and in which region/datacenter the VM's should be deployed. For demo purposes this script requires you to supply all the information 
    instead of supplying the information to the script's parameters. When all information is validated PowerShell's parallel workflow execution will be used 
    to deploy the VM's and related storage accounts. Note: PowerShell workflow in version 3 is limited with a hardcoded maximum of five simultaneous threads, 
    there are some workarounds and solutions (runspaces/jobs) to expand the number of threads but it's wiser to be on the safe side and avoid running
    into any kind of restriction or thread limitation in Azure. 
    
    Important: Please be aware of the Azure VM Core and Cloud Service limit in Azure (default 20), open up a support ticket with Microsoft to raise the limit.
    See: http://azure.microsoft.com/en-us/documentation/articles/azure-subscription-service-limits/#subscription-limits
    
    .PARAMETER SubscriptionName
    Supply the 'Subscriptionname' parameter when you want to use a particular subscription, by default it chooses the currently active one.

    .PARAMETER InstanceSize
    Used for the VM compute resource size (CPU,Memory,Disk), for example 'ExtraSmall','Small','Medium' etc. The default value is set to 'Small'.
    For more information see 'http://msdn.microsoft.com/library/azure/dn197896.aspx'.

    .PARAMETER VMprefix
    This prefix combined with the short name of the location generated by the script forms the unique VM and DNS name.
    The DNS name must be unique in Azure's public cloud DNS namespace, *.cloudapp.net.
    For example the name of the VM in 'East Asia' with prefix 'DEMO3-' forms 'DEMO3-EA'.

    .PARAMETER StorageAccountPrefix
    This prefix combined with the short name of the location generated by the script forms the unique Storage Account name in Azure.
    Storage account names use numbers and lower-case letters only.
    For example the name of the Storage Account in 'East Asia' with prefix 'demo3' forms 'demo3ea'.

    .PARAMETER ImportPubFile
    Specify this switch parameter to use the certificate import with 'Import-AzurePublishSettingsFile' instead
    of the default 'add-azureaccount' method where the account will expire after 12 hours.
    Simply said, by using the certificate method you don't have to re-authenticate every 12 hour. 

    .PARAMETER AddSubscription
    Specify this switch parameter add a new Azure Subscription, only use this switch 
    when you already have a existing Azure subscription and want to add a new one to use with this script. 

    .EXAMPLE 
    .\AzureDemo_ProvisionVMsGlobally.ps1

    .EXAMPLE 
    .\AzureDemo_ProvisionVMsGlobally.ps1 -SubscriptionName 'Enterprise'

    .EXAMPLE 
    .\AzureDemo_ProvisionVMsGlobally.ps1 -AddSubscription

    .EXAMPLE 
    .\AzureDemo_ProvisionVMsGlobally.ps1 -SubscriptionName 'Enterprise' -InstanceSize 'Small' -VMprefix 'DEMO3-' -StorageAccountPrefix 'demo3' -ImportPubFile -AddSubscription
 
 
#>

[CmdletBinding()]
    Param(     
    [Parameter(HelpMessage = 'Enter the Azure subscription name, for example; Enterprise or Trial.
    Leave empty to determine the subscription automatically.',ParameterSetName = "2")] 
    [Alias('Subscription','AzureSubscription')]  
    [ValidateLength(3,50)]         
    [String]$SubscriptionName,
    [Parameter(HelpMessage="Enter the casesensitive VM size, for example 'ExtraSmall','Small','Medium' etc.
    See 'http://msdn.microsoft.com/library/azure/dn197896.aspx' for available sizes.")]      
    [String]$InstanceSize = 'Small',
    [Parameter(HelpMessage="This prefix combined with the the location forms the VM name,
     for example prefix 'VM-' will form the name 'VM-EA' in East Asia")] 
    [ValidateLength(2,8)]         
    [String]$VMprefix,
    [Parameter(HelpMessage="This prefix combined with the the location forms the storage account name,
     for example prefix 'stor' will form the name 'storeastasia' in East Asia")]
    [ValidateLength(2,8)]         
    [String]$StorageAccountPrefix,
    [Parameter(HelpMessage="Specify this switch to use the certificate import instead of the 'Add-AzureAccount' method 
    which expires after 12 hours.")]        
    [Switch]$ImportPubFile,
    [Parameter(HelpMessage="Specify this switch to add a new Azure subscription")]        
    [Switch]$AddSubscription  
    )   


BEGIN {

    # 
    # Prerequisites check
    ##

    $ErrorActionPreference = [System.Management.Automation.ActionPreference]::Stop

    # Checks for a 64bit environment, otherwise PS workflow won't work.

    if (![Environment]::Is64BitProcess){
        write-warning 'This script uses Windows PowerShell Workflow which is not supported in a Windows PowerShell x86-based console.  Open a Windows PowerShell x64-based console, and then try again.'
        break
    } # end if

    # Checks for the Azure module availability and import when necessary

    if (!(Get-Module -Name Azure -ListAvailable)) 
    {
    
        $AzureModule = "${env:ProgramFiles(x86)}\Microsoft SDKs\Azure\PowerShell\ServiceManagement\Azure\Azure.psd1"

        if (Test-Path $AzureModule){
            Import-Module $AzureModule -Global
        } else {
            Write-Warning 'Azure PowerShell module not detected, please download and install from ''https://github.com/Azure/azure-powershell/releases'' and rerun this script.'
            break
        } # end if azuremodule

    } else {

      Import-Module Azure 

    } # end if Azuremodule check

    # 
    # Functions
    ##

    Function Global:Create-AzureVM 
    {
        <#
            .SYNOPSIS
            Creates an Azure VM in a Azure data center location determined by the specified storage account.

            .DESCRIPTION
            This function creates a Azure Virtual machine using the 'New-AzureQuickVM' cmdlet in an Azure data center location determined by the specified storage account.
            It takes the VM name (mandatory), instance size, image, storage account name (also represents the location), credential and subscription as input.
            The optional parameters default to the chosen values of the main script routine itself. Except for the 'StorageAccountName', when the
            'StorageAccountName' is not specified the function will present a list with available storage accounts to choose from. 
            You will be asked for the optional parameters when the default script variables are not populated.
            See the parameter descriptions for more information or use 'help Create-AzureVM -examples' to see several input examples.
         
            .PARAMETER Name
            One or more Virtual Machines to operate against. Accepts pipeline input ByValue and ByPropertyName.
            .PARAMETER InstanceSize
            Used for the VM compute resource size (CPU,Memory,Disk), for example 'ExtraSmall','Small','Medium' etc. Default value is set to 'Small'.
            For more information see 'http://msdn.microsoft.com/library/azure/dn197896.aspx'
            .PARAMETER ImageName
            Enter a available Azure VM image, like 'a699494373c04fc0bc8f2bb1389d6106__Windows-Server-2012-R2-201411.01-en.us-127GB.vhd'.
            When left blank, the function uses the 'ImageName' variable which was set by the script's main routine. If the variable is not set it 
            executes the 'Retrieve-Image' function, this allows you to use the latest image for the selected Windows image family.
            .PARAMETER StorageAccountName
            This is the fully written Storage Account Name, all in lowercase and limited to 24 characters.
            .PARAMETER Credential
            Expects a PS credential object 'Get-Credential'. When left blank, it uses the 'VMcred' credential variable which was asked in the main routine,
            it requests a new credentials when the VMcred variable is empty.
            .PARAMETER SubscriptionName
            Supply the 'Subscriptionname' parameter when you want the script to use a particular subscription, by default it chooses the currently active one.
            .PARAMETER SleepinMS
            Used for the main routine only, built-in sleep, this we way PS workflow doesn't run into the dreadful AzureProfile.json being used by another process when switching
            the storage account in the active subscription. This change is written in the AzureProfile.json profile file which can't be accessed by multiple processes/threads simultaneously.
            .EXAMPLE
            Create-AzureVM VM1
            .EXAMPLE
            Create-AzureVM VM2 -Instance Large -ImageName (Retrieve-Image) -Credential (Get-Credential) 
            .EXAMPLE
            Create-AzureVM VM3 -Instance Small -ImageName 'a699494373c04fc0bc8f2bb1389d6106__Windows-Server-2012-R2-201411.01-en.us-127GB.vhd' -StorageAccountName storeastasia -Credential $VMCred 
            .LINK
            www.ruudborst.nl
        #>

        
        [CmdletBinding(SupportsShouldProcess = $True)]
        Param(            
            [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True,HelpMessage='Enter the virtual machine name')] 
            [Alias('ComputerName','MachineName','Server','VM')]  
            [ValidateLength(3,15)]         
            [string[]]$Name,
            [Parameter(HelpMessage = "Enter the casesensitive VM size, for example 'ExtraSmall','Small','Medium' etc.
            See 'http://msdn.microsoft.com/library/azure/dn197896.aspx'.")]  
            [Alias('Instance')]      
            [String]$InstanceSize = $InstanceSize,
            [Parameter(HelpMessage = "Supply a available Azure VM image, like `
            'a699494373c04fc0bc8f2bb1389d6106__Windows-Server-2012-R2-201411.01-en.us-127GB.vhd'")]    
            [ValidateScript({try {if (!(get-AzureVMimage -imagename $_ -ea 0)){$false}else{$True}}catch{$true}})] 
            [String]$ImageName = $ImageName,  
            [Parameter(HelpMessage = 'Enter the Storage Account name')] 
            [Alias('StorageAccount')]  
            [ValidateLength(3,24)]
            [ValidateScript({$_ -cmatch "^[a-z0-9]*$"})]          
            [string]$StorageAccountName = ((Get-AzureStorageAccount -Wa 0).StorageAccountName `
            | Out-GridView -Title 'Please select a Storage Account' -PassThru),
            [Parameter(HelpMessage = 'Supply a PSCredential object (username/password)')]    
            [Alias('VMcred')]     
            [PSCredential]$Credential = (Get-Credential $VMcred),
            [Parameter(HelpMessage = 'Enter the Azure subscription name, for example; Enterprise or Trial.
             Leave empty to determine the subscription automatically.')] 
            [Alias('Subscription','AzureSubscription')]  
            [ValidateLength(3,50)]         
            [String]$SubscriptionName,
            [Parameter(HelpMessage = 'For PS workflow multiple processes usage.')]       
            [int]$SleepinMS
        )
   
        BEGIN {

        # Creates a hashtable to store the newly created VM's.
        # This way we won't have to execute a slow live query to Azure.

            if (!$VMtoLoc)
            {
                $Global:VMtoLoc = @{}
            } # end if vmtoloc

            # Checks for Azure module, needed for workflow execution when the module is just installed, this way you won't have to restart the PowerShell console

            if (!(Get-Module -Name Azure -ListAvailable)) 
            {
            $AzureModule = 'C:\Program Files (x86)\Microsoft SDKs\Azure\PowerShell\ServiceManagement\Azure\Azure.psd1'
              if (Test-Path $AzureModule){
                Import-Module $AzureModule -Global
               } else{
                Write-Warning 'Azure PowerShell module not detected, please download and install from ''https://github.com/Azure/azure-powershell/releases'' and rerun this script.'
               break
               } # end if azuremodule
            } else {
             Import-Module Azure
            } # end if Azuremodule check

            # Allows you to select the image via the 'Retrieve-Image' function when the ImageName parameter is empty

            if (!$ImageName) {

               Write-Host "Could not determine the image file name, please choose which image you want to use, executing function 'Retrieve-Image' ..."
                $Global:ImageName = Retrieve-Image

            } # end if image

            # Built-in sleep, this we way PS workflow doesn't run into the dreadful AzureProfile.json being used by another process
            # when you switch the storage account in the active subscription, the change happens in the profile file which can't be accessed by multiple processes/threads at once

            if ($SleepinMS){
             Sleep -Milliseconds $SleepinMS
            } # end if SleepinMS

            # Sets the subscriptionname to the current active subscription name when not supplied

            if (!$SubscriptionName){
              $SubscriptionName = (Get-AzureSubscription | ? IsCurrent -eq $True).SubscriptionName
            } # end if !SubscriptionName

            # Sets the new supplied credential as the globally used default credential

            if (!$VMcred){
             $Global:VMcred = $Credential
            } # end if

            # Retrieve the storage account location

            $Location = (Get-AzureStorageAccount $StorageAccountName -Wa 0).Location

            # Sets the subscription to work with the selected storage account

            Set-AzureSubscription -currentstorageaccount $StorageAccountName -SubscriptionName $SubscriptionName

        } # end BEGIN block
     
  

        PROCESS {

            if ($pscmdlet.ShouldProcess($Name))
            {
         
                $Name | ForEach -Process {
                    
                    $VM = $_
  
                    # Creates the VM when it doesn't exist

                    if (!(Get-AzureVM $VM -Wa 0 -Ea 0))
                    {
                        "[Creating] '$VM' in '$Location' ..."

                        try 
                        {
                            New-AzureQuickVM -Windows -ServiceName $VM -name $VM -ImageName $ImageName -Password ($Credential.GetNetworkCredential().Password) `
                            -InstanceSize $InstanceSize -adminuser $Credential.UserName  -Location $Location `
                            -MediaLocation "http://$StorageAccountName.blob.core.windows.net/vhds/$VM.vhd" -ErrorAction Stop | Out-Null
                            $VMtoLoc[$VM] = $Location
               
                            "[Created]  '$VM' in '$Location'" 
                        }
                        catch 
                        {
                            "[Failed] '$VM' in '$Location'"
                            write-error $_.Exception.Message
                        } # end try/catch
                    }
                    else 
                    {
                        "[Exists] '$VM' already exists."
                    } # end if Get-AzureVM

                } # end foreach Name

            } # end if ShouldProcess
        } # end process block
    } # end Create-AzureVM function

    Function Global:Create-AzureStorageAccount 
    {
        <#
            .SYNOPSIS
            Creates an Azure Storage Account based in given Azure data center location.
            .DESCRIPTION
            This function creates a storage account using the 'New-AzureStorageAccount' cmdlet in the specified datacenter location. 
            .PARAMETER Name
            The fully written Storage Account Name, all in lowercase and limited to 24 characters. Accepts pipeline input ByValue and ByPropertyName.
            .PARAMETER Location
            The Azure datacenter location name, use the 'Get-AzureLocation' cmdlet for a list of available datacenters.

            .EXAMPLE
            Create-AzureStorageAccount stornorthcentralus -Location 'North Central US'
            .LINK
            www.ruudborst.nl
        #>


        [CmdletBinding(SupportsShouldProcess = $True)]
        Param(            
            [Parameter(Mandatory = $True,ValueFromPipeline = $True,ValueFromPipelineByPropertyName=$True,HelpMessage = 'Enter the Storage Account name')] 
            [Alias('StorageAccount','StorageAccountName')]  
            [ValidateLength(3,24)]
            [ValidateScript({$_ -cmatch "^[a-z0-9]*$"})]          
            [string[]]$Name,
            [Parameter()] 
            [ValidateLength(3,24)]        
            [string]$Location = ((Get-AzureLocation | where availableservices -Contains 'Compute').name | 
            Out-GridView -PassThru -Title "Select one data center location to create the storage account in.")
        )  

        BEGIN {

        # Creates a hashtable to store the newly created accounts.
        # This way we won't have to execute a slow live query to Azure.

            if (!$STtoLoc)
            {
              $Global:STtoLoc = @{}
            } # end if Stloc

            # Checks for Azure module, needed for workflow execution when the module is just installed, this way you won't have to restart the PowerShell console

            if (!(Get-Module -Name Azure -ListAvailable)) 
            {
             $AzureModule = 'C:\Program Files (x86)\Microsoft SDKs\Azure\PowerShell\ServiceManagement\Azure\Azure.psd1'
              if (Test-Path $AzureModule){
                Import-Module $AzureModule -Global
               } else{
                Write-Warning 'Azure PowerShell module not detected, please download and install from ''https://github.com/Azure/azure-powershell/releases'' and rerun this script.'
               break
               } # end if azuremodule
            } else {
             Import-Module Azure
            } # end if Azuremodule check

        } # end BEGIN block

        PROCESS {

            if ($pscmdlet.ShouldProcess($Name))
            {
                $Name | ForEach -Process {

                    try {

                        # Creates the Storage Account in the given datacenter location

                        if (!(Get-AzureStorageAccount $_ -Wa 0 -Ea 0)) {
                            
                            "[Creating] '$_' in '$Location' ..."
   
                            New-AzureStorageAccount -StorageAccountName $_ -location $Location | Out-Null

                            "[Created]  '$_' in '$Location'"
                            $STtoLoc[$_] = $Location

                        } else {
                            "[Exists] '$_' in '$Location'"
                        } # end if Storage Account created

                    } Catch { 

                        Write-Host "An error occured trying to create the Storage Account '$Name' in location '$Location'"
                        write-error $_.Exception.Message

                    } # end try/catch

                } # end foreach Name

            } # end if ShouldProcess
        } # end process block
    } # end Create-AzureStorageAccount function

    Function Global:ConnectTo-Azure 
    {
        <#
            .SYNOPSIS
             Connects to the Azure subscription.
            .DESCRIPTION
             This function tries retrieves the subscription details and establishes an administrative connection to Azure.
            .EXAMPLE
             ConnectTo-Azure
            .PARAMETER SubscriptionName
             Enter the Azure subscription name, leave blank to determine the name automatically.
            .PARAMETER ImportPubFile
             Specify this switch parameter to use the certificate import instead of the default 'add-azureaccount' method which expires after 12 hours.
             By using the certificate method you don't have to authenticate each time your 12 hour session expires. 
            .PARAMETER AddSubscription
             Specify this switch parameter add a new Azure Subscription via the 'Add-AzureAccount method, only use this switch 
             when you already have a existing Azure subscription and want to add a new one to use with this script. 
        #>

        [CmdletBinding()]
        Param(
            [Parameter(HelpMessage = 'Enter the Azure subscription name')] 
            [Alias('Subscription','AzureSubscription')]  
            [ValidateLength(3,50)]  
            [String]$SubscriptionName = $SubscriptionName,
            [Parameter(HelpMessage="Specify this switch to use the certificate import instead of the 'Add-AzureAccount' method 
            which expires after 12 hours.")]        
            [Switch]$ImportPubFile,
            [Parameter(HelpMessage="Specify this switch to add a new Azure subscription.")]  
            [Alias('ReloadSubscription')]      
            [Switch]$AddSubscription  
             )  

        Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

        # Delete expired azure user accounts when the import publish certificate file is used.
        # Otherwise the subscription tries to use the already used but expired azure user account. 

        if ($ImportPubFile){
        
            Get-AzureAccount | where type -eq user | foreach {
                Remove-AzureAccount -name $_.id -force -WarningAction SilentlyContinue -ErrorAction SilentlyContinue
            } # end foreach get-azureaccount

        } # end if ImportPubFile

           function ImportPubFile {


            "`nUsing the import publish file method to retrieve the subscription."
            "For more information see 'http://msdn.microsoft.com/en-us/library/dn495124.aspx'"

            Sleep 2

            "The default browser will redirect you to the Azure portal where the subscription file can be retrieved. Save this file on the filesystem and specify the directory in the next prompt. The file will be deleted afterwards."
            Pause

            Get-AzurePublishSettingsFile 

            $PublishSettingsFileDir = Read-Host -Prompt 'Please specify the directory containing the saved connection file'
            $FileDirExists = Test-Path $PublishSettingsFileDir

            if ($FileDirExists -eq $True) 
            {
                $PublishSettingsFile = Get-ChildItem $PublishSettingsFileDir -Filter *.publishsettings |
                Sort lastwritetime  |
                Select -Last 1

                if ($PublishSettingsFile)
                {
                    Write-Host "`nImporting publish file $PublishSettingsFile ..."
                    Sleep -Seconds 2
                    Import-AzurePublishSettingsFile $PublishSettingsFile.FullName -Verbose
                    "Deleting import publish file $PublishSettingsFile ..."
                    Remove-Item -Path $PublishSettingsFile.FullName -Force -Verbose

                } else {
                    Write-Warning -Message "Couldn't locate the file in directory $PublishSettingsFileDir."
                    'Please try again or execute the steps manually via`nhttp://azure.microsoft.com/en-us/documentation/articles/install-configure-powershell/ and re-run the script.'
                } #end if PublishSettingsFile

            } else {

                Write-Error -Message "Directory $PublishSettingsFileDir doesn't exist. Aborting script."
                break

            } # end if FileDirExists

        } # end importpubfile function

        if ($AddSubscription){

            write-host "'AddSubscription' parameter specified, adding a new subscription ..." 
           
            if (!$ImportPubFile){
                Add-AzureAccount
            }else{
            . ImportPubFile
            } # end if importpubfile

        } # end if AddSubscription

        $AzureSubscription = Get-AzureSubscription -ea 0

        $SubscriptionCount = ($AzureSubscription).count

        if ($AzureSubscription -and $SubscriptionName){

            $Subscription = $AzureSubscription | Where SubscriptionName -eq $SubscriptionName

                if (!$Subscription){            
                    Write-Warning -Message "No registered Azure Subscription found with subscription name $SubscriptionName"
                } # end if Subscription

            } elseif ($SubscriptionCount -eq 1 -and !$SubscriptionName){

            write-host "`nSubscriptionName parameter is not specified, trying to use the current active subscription.`nIf you don't see your subscription then please run the script or this function with parameter '-AddSubscription'."
            $Subscription = $AzureSubscription | Where IsCurrent -eq $True

            } elseif ($SubscriptionCount-gt 1 -and !$SubscriptionName){

             write-host "`nSubscriptionName parameter is not specified, found multiple subscriptions, please choose a subscription to use.`nIf you don't see your subscription then please run the script or this function with parameter '-AddSubscription'."
             Pause
             $Subscription = $AzureSubscription | where SubscriptionName -eq ($AzureSubscription | Select SubscriptionName,Accounts,IsDefault,IsCurrent | Out-Gridview -Title 'Please select the subcription to use' -PassThru).SubscriptionName

       } # end if AzureSubscription/SubscriptionName

        if (!$Subscription){
        
        "No registered or active Azure Subscription found, trying to retrieve the subscription details from Azure ..."
        Pause

        # Execute the importpubfile function in this function when the importpubfile parameter is specified otherwise the add-azureaccount Azure cmdlet is used

            if (!$ImportPubFile){
                Add-AzureAccount
            }else{
            . ImportPubFile
            } # end if importpubfile

            $AzureSubscription = Get-AzureSubscription -ea 0

               if ($AzureSubscription -and $SubscriptionName){

                $Subscription = $AzureSubscription | Where SubscriptionName -eq $SubscriptionName

                    if (!$Subscription){            
                    Write-Warning -Message "No registered Azure Subscription found with subscription name $SubscriptionName. Please re-run the function/script with a valid subscriptionname or leave it empty to use the current active one."
                    } # end if Subscription

               } elseif ($AzureSubscription -and !$SubscriptionName){

                Write-Host "`nSubscriptionName parameter is not specified, trying to use the current active subscription."
                $Subscription = $AzureSubscription | Where IsCurrent -eq $True

                    if (!$Subscription){            
                        Write-Warning -Message "No registered or active Azure Subscription found. 'Please try again or use 'ConnectTo-Azure' with the '-ImportPubFile' parameter to use the Import publish file settings method. You could also execute the steps manually via`n'http://azure.microsoft.com/en-us/documentation/articles/install-configure-powershell/' and re-run the script."
                    break
                    } # end if Subscription

               } # end if AzureSubscription

         } # end if !Subscription

        $SubscriptionName = $Subscription.SubscriptionName

        Select-AzureSubscription -SubscriptionName $SubscriptionName

        Write-Host "`nSelected the '$SubscriptionName' subscription as the active Azure subscription.`n"

        $Global:SubscriptionName = $SubscriptionName

        # Sets the available Azure Datacenter locations containing the 'Compute' resource to an array.

        $Global:Locations = try{(Get-AzureLocation | where availableservices -Contains 'Compute' -ea 0).Name}catch{}

        # Check for expired credentials

        if (!$Locations) {
         write-warning "It seems the Azure credentials have not been set up or have expired, please re-authenticate with the credentials of the '$SubscriptionName' subscription."
         Pause

            if (!$ImportPubFile){
               Add-AzureAccount
            }else{
            . ImportPubFile
            } # end if importpubfile

         $Global:Locations = (Get-AzureLocation | where availableservices -Contains 'Compute').Name

        } # end if Locations
       
    } # end function ConnectTo-Azure

    Function Global:CleanUp-Demo
    {
        <#
            .SYNOPSIS
             Deletes all VM's and tied storage accounts created with this script.
            .DESCRIPTION
             This function triggers the 'Delete-AzureVM' and the 'Delete-AzureStorageAccount' function 
             and helps you to clean-up the demo VM's and related storage accounts.
            .LINK
             www.ruudborst.nl
        #>

            Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

           # Identify the VM's and Storage Accounts created with last execution of this script

           if ($Vmprefix -and $Storageaccountprefix){

             $DemoVMs = $VMtoLoc.keys | where {$_ -match "^$Vmprefix"}
             $DemoSTs = $STtoLoc.keys | where {$_ -match "^$Storageaccountprefix"}

             'This function triggers the ''Delete-AzureVM'' and the ''Delete-AzureStorageAccount'' function and helps you to clean-up the demo VM''s and related storage accounts created with this script.' 
             Pause

                if ($DemoVMs -ge 1){

                    "`nDemo VM's"
                    '-------------'
                    $DemoVMs

                    # Delete the Azure VM through the script's 'Delete-AzureVM' function , a confirmation will be asked for each VM.
                    $DemoVMs | Delete-AzureVM

                } else {
                    "`nNo VM's found with prefix $VMprefix. Please try 'Delete-AzureVM -Retrieve' and choose one or more VM's.`n"
                } # end if DemoVMs

                if ($DemoSTs -ge 1){

                    Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

                    "`nDemo Storage Accounts" 
                    '-------------'
                    $DemoSTs

                    # Delete the Azure Storage Account through the script's 'Delete-AzureStorageAccount' function , a confirmation will be asked for each Storage Account.

                    $DemoSTs | sort | Delete-AzureStorageAccount

                } else {
                    "No storage accounts found with prefix $Storageaccountprefix. Please try 'Delete-AzureStorageAccount -Retrieve' and choose the storage account you want to delete."
                } # end if DemoSTs

          } else {

                Write-Warning "Prefix isn't set, could not identify demo Azure objects. Please try to delete the objects manually via 'Delete-AzureVM -Retrieve' or 'Delete-AzureStorageAccount -Retrieve'"
          
          } # end if prefix

    } # end CleanUp-Demo function

    Function Global:Retrieve-Image 
    {
        <#
            .SYNOPSIS
            Retrieves the latest Windows Image from Azure, this image is used for the VM deployment.
            .DESCRIPTION
            This function retrieves all Windows family type images with the 'Get-AzureVMImage' cmdlet and prompts which family type you want to use.
            It then selects the latest published image for the chosen family type and sets that name as a string to the imagename script variable.
            .EXAMPLE
            Retrieve-Image
        #>
        
        # Retrieve all Windows Family Images

        $Images = Get-AzureVMImage | Where { $_.imagefamily -match '^Windows Server'}

        # Prompt which image family to use and select the latest image for it

        $ImageFamily = ($Images | Group imagefamily).name | Out-GridView -Title 'Choose a Windows OS, the script will automatically select the latest image.' -PassThru

        if ($ImageFamily) {
            $Global:ImageName = ($Images | Where{ $_.imagefamily -eq $ImageFamily } | Sort  publisheddate -Descending | Select -First 1).ImageName
            $ImageName
        } else {
            'No input received.'
        } # end if ImageFamily

    } # end retrieve-image function

    Function Global:Index-VMinfo 
    {
        <#
            .SYNOPSIS
            Retrieves and indexes storage account and VM information from Azure.
            .DESCRIPTION
            Retrieves VM and storage account information from Azure and stores it into the relevant hash tables.
            The function uses the script's VM and storage account prefix to retrieve only the created objects created
            with this script. Specify the 'All' parameter to index all VM's and storage accounts. Information from this function
            is retrieved by the 'Select-VM' function which allows you to select a VM without waiting for any slow running Azure queries.
            .PARAMETER All
            Specify the All switch parameter to index all VM's under the current Azure subscription and not just
            the ones created by this script.
            .PARAMETER PreVM
            Specify the VM prefix.
            .PARAMETER PreSt
            Specify the storage account prefix.
            .EXAMPLE
            Index-VMinfo
            .EXAMPLE
            Index-VMinfo -All
            .EXAMPLE
            Index-VMinfo -PreVM demo9 -PreSt demo9
        #>


        [CmdletBinding(DefaultParametersetName="2")]
        Param(
            [Parameter(ParameterSetName = "1",HelpMessage="This prefix combined with the the location forms the VM name,
             for example prefix 'VM-' will form the name 'VM-EA' in East Asia")]             
            [String]$PreVM=$VMprefix,
            [Parameter(ParameterSetName = "1",HelpMessage="This prefix combined with the the location forms the storage account name,
             for example prefix 'stor' will form the name 'storeastasia' in East Asia")]           
            [String]$PreSt=$StorageAccountPrefix,         
            [Parameter(ParameterSetName = "2")]            
            [Switch]$All,
            [Parameter(ParameterSetName = "1")]            
            [Switch]$NoInfo
        )   

        # Make sure prefixes are null when specifying the '-All' parameter switch

        if ($All){

            $PreVM = $null
            $PreSt = $null

        } # end if All

        Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan 
        Write-Host 'Retrieving and indexing VM and storage information.'

        # Defining all global indexing variables if they don't already exist

        if (!$VMtoLoc){$Global:VMtoLoc = @{}}
        if (!$VMtoUri){$Global:VMtoUri = @{}}
        if (!$VMtoRDP){$Global:VMtoRDP = @{}}
        if (!$VMtoIP){$Global:VMtoIP = @{}}
        if (!$WinRMFwInfo){$Global:WinRMFwInfo = @()}
        if (!$STtoLoc){$Global:STtoLoc = @{}}

        Write-Host "`nRetrieving Storage Accounts using 'Get-AzureStorageAccount' ..."

        $GetAzureST =  Get-AzureStorageAccount -wa 0 | Where StorageAccountName -match "^$PreSt" 

        $GetAzureST | ForEach {
            $STtoLoc[$_.StorageAccountName] = $_.Location
        } # end foreach GetAzureST

        # Outputs retrieved and indexed storage account information when the NoInfo switch isn't specified

        if (!$NoInfo){
            $GetAzureST | ft StorageAccountName,Location,@{Name="Endpoint";Expression={$_.endpoints[0]}} -AutoSize
        } # end if NoInfo

        Write-Host "`nRetrieving VM's and Endpoints using 'Get-AzureVM' ..."

        $GetAzureVM = Get-AzureVM | Where Name -match "^$PreVM" 

        # Indexes and converts all VM information including RemoteDesktop and PowerShell url's into hash tables

        if ($GetAzureVM.count -ge 1){

            $GetAzureVM | ForEach -Process {

                $St = $_.vm.OSVirtualHardDisk.MediaLink.Host -replace "\.blob.core.windows.net",""
                $VMname = $_.Name
                $VMIP = $_.IpAddress   

                $Endpoint = $_ | Get-AzureEndpoint | where name -eq 'PowerShell'

                $IP = $Endpoint.vip
                $Port = $Endpoint.port
                $Uri = "https://$IP`:$Port"
                $Global:VMtoUri[$VMname] = $Uri
                $Global:VMtoIP[$VMname] = $VMIP 

                $Endpoint = $_ | Get-AzureEndpoint | where name -eq 'RemoteDesktop'

                if ($_.DNSName -match "//(.*)/"){$hostname = $Matches[1]} 

                $RDPaddress = $hostname + ":" + $Endpoint.Port
                $Global:VMtoRDP[$VMname] = $RDPaddress

                $VMtoLoc[$VMname] = $STtoLoc[$St]

                $WinRMFwInfo += [pscustomobject]@{
                    VM   = $VMname
                    Size   = $_.InstanceSize
                    Location = $VMtoLoc[$VMname]
                    URI  = $_.DNSName
                    PSport = $Port
                 } # end pscustomobject

            } # end foreach GetAzureVM

        } else {
         'No VM''s found.' 
        } # end if GetAzureVM.count

        # Outputs VM name,size,location and remote PS information when the NoInfo switch isn't specified

        if (!$NoInfo){
         $WinRMFwInfo | ft -AutoSize
        } # end if NoInfo

    } # end function Index-VMinfo

    Function Global:Setup-Session 
    {
        <#
            .SYNOPSIS
            Sets up a remote PSsession to the AzureVM.
            .DESCRIPTION
            Checks for an existing PSsession for the supplied VM and if it is not open yet opens up a new one with the 'New-PSSession' cmdlet.
            The PSsession is supplied with a SessionOption parameter which ignores the Certificate Authority check and sets a idle timeout of one hour. 
            This function is used by the 'execute-remotecommand' function to set up the VM connection before executing a remote PS command.
            .PARAMETER Name
            One or more Virtual Machines to operate against. Accepts pipeline input ByValue and ByPropertyName.
            .PARAMETER Credential
            By default the script uses the VMcred credential which was used to create the VM's by this script.
            You can specify a different PScredential object or execute '(get-credential)'. 
            .EXAMPLE
            Setup-Session VM-NCU
            .EXAMPLE
            Select-VM -All | Setup-Session -Cred (get-credential)
        #>

        [CmdletBinding(SupportsShouldProcess = $True)]
        Param(            
            [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True,HelpMessage='Enter the VM name')] 
            [Alias('ComputerName','MachineName','Server','VM')]   
            [ValidateLength(3,15)]         
            [string[]]$Name,
            [Parameter(HelpMessage = "Specify a different PScredential object or execute '(get-credential)'. 
            By default it uses the credentials which was used for the VM creation.")]   
            [Alias('cred')]           
            [PsCredential]$Credential          
        )   

        BEGIN {

            # Skip CA PSsession check and configure a 1hour idletimeout
            if (!$SessionOption) 
            {
                $Global:SessionOption = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck -IdleTimeout 3600000
            } # end if

        if (!$VMtoUri){$Global:VMtoUri = @{}}
        if (!$VMtoIP){$Global:VMtoIP = @{}}
        if (!$WinRMFwInfo){$Global:WinRMFwInfo = @()}

        } # end begin block

        PROCESS {

            if ($pscmdlet.ShouldProcess($Name)) {

            $Name | foreach {
                $VM = $_
                [string]$state = (Get-PSSession -Name $VM -ea 0).state 

                if ($state -ne 'Opened' -or $Credential)
                {
                   Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

                    if (!$VMtoUri[$VM])
                    {
                        
                        "Could not find '$VM' WinRM remote management url in the VMtoUri hashtable.`n"
                        "Press 'y' to execute the 'Index-VMinfo -All' function and index all VM WinRM url's from Azure or press any other key to abort the session setup.`n"

                        $IndexVMs = Read-Host  -Prompt "Index WinRM url's (y/n)?"

                        if ($IndexVMs -eq 'y') 
                        {
                            Index-VMinfo -All
                            Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan
                        }
                        else 
                        {
                            break
                        } # end if indexvms

                    } # end if vmtouri
            
                    Write-Host "Establishing a remote session to $VM ..."

                    if (!$VMcred -and !$Credential) 
                    {
                        $Global:VMcred = Get-Credential -Message "Please supply the Azure Virtual Machine Windows Administrator`n user name and password."
                    } # end if vmcred/!credential

                    Remove-PSSession -Name $VM -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

                    if ($Credential){
                     $SesCred=$Credential
                    }else{
                     $SesCred=$Vmcred
                    } # end if Credential

                    try {

                     $WinRMuri = $VMtoUri[$VM]
                     New-PSSession -Credential $SesCred -ConnectionUri $WinRMuri -SessionOption $SessionOption -Name $VM -erroraction stop;''
                    
                    } catch {

                     Write-Host "`n"
                     write-warning "An error occured trying to establish a PSSession to $WinRMuri`nPlease verify connectivity to the '$VM' or wait for the VM to start up."
                     Write-Host "`n"
                     Write-Host $_.exception.message

                    } # end catch


                } # end if state

                $IP = $VMtoIP[$VM]
                $Loc = $VMtoLoc[$VM]
                $Os = $VMtoOS[$VM]
  
                $Sessioninfo = [pscustomobject]@{
                    VM = "$VM"
                }

                if ($Loc)
                {
                    $Sessioninfo = [pscustomobject]@{
                        VM       = "$VM"
                        IP       = "$IP"
                        Location = "$Loc"
                    }

                } # end if

                if ($Os)
                {
                    $Sessioninfo = [pscustomobject]@{
                        VM       = "$VM"
                        IP       = "$IP"
                        Location = "$Loc"
                        OS       = "$Os"
                    }

                } # end if
            } # end if ShouldProcess
          } # end foreach VM
        } # end process block
    } # end function Setup-Session 

    Function Global:Execute-RemoteCommand 
    {
        <#
            .SYNOPSIS
            Allows you to execute remote PowerShell commands to the Azure VM.
            .DESCRIPTION
            Executes the supplied command provided in the scriptblock parameter with the 'invoke-command' cmdlet
            on one or more Azure VM's supplied in the Name variable to this function. Also a new session will be 
            created by the 'setup-session' function if there isn't one already.
            .PARAMETER Name
            One or more Virtual Machines to operate against. Accepts pipeline input ByValue and ByPropertyName.
            .PARAMETER ScriptBlock
            Is mandatory and accepts a scriptblock '-Scriptblock {'hello world'}' as input. 
            .PARAMETER Credential
            By default the script uses the VMcred credential which was used to create the VM's by this script.
            You can specify a different PScredential object or execute '-credential (get-credential)'. 
            .EXAMPLE
            Select-VM -All | Execute-RemoteCommand
            .EXAMPLE
            Execute-RemoteCommand VM-NCU -Scriptblock $httpconnect
            .EXAMPLE
            Execute-RemoteCommand VM-NCU -Scriptblock {$psversiontable} -Credential (get-credential)
            .LINK
            www.ruudborst.nl
        #>

        [CmdletBinding(SupportsShouldProcess = $True)]
        Param(            
            [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True,HelpMessage='Enter the VM name')] 
            [Alias('ComputerName','MachineName','Server','VM')]   
            [ValidateLength(3,15)]         
            [string[]]$Name,
            [Parameter(HelpMessage = "Specify a PowerShell ScriptBlock or supply your own, for example '{whoami}'")]   
            [Alias('sb')]           
            [ScriptBlock]$ScriptBlock=$httpconnect,
            [Parameter(HelpMessage = "Specify a different PScredential object or execute '(get-credential)'. 
             By default it uses the credentials which are used for the VM creation.")]   
            [Alias('cred')]           
            [PsCredential]$Credential             
        )  
    

        BEGIN {

            Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan
            
            # Instantiate VM to OS hash if it doesn't exist to store the OS to VM mapping

            if (!$Global:VMtoOS)
            {
                $Global:VMtoOS = @{}
            } # end if VMtoOS

            $Errmessages=@()
            $Global:Results = @()

        } # end begin block

        PROCESS {

            if ($pscmdlet.ShouldProcess($Name)) {
                
                
                $Name | ForEach {

                    $Output = $null
                    $OSinfo = $null
                    $VMe = $_.toUpper()

                    # Initiates and checks for a WinRM Remote PS session

                    Setup-Session $VMe $Credential

                    $Session = Get-PSSession -Name $VMe -ErrorAction 0

            
                    if ($Session){
                    
                    # Store the OS information in the hashtable if it doesn't exist

                        if (!$VMtoOS[$VMe])
                        {
                            $OSinfo = Invoke-Command -Session (Get-PSSession -Name $VMe) -ScriptBlock {
                                (Get-WmiObject  -Class win32_operatingsystem).caption
                            } # end scriptblock
                            $Global:VMtoOS[$VMe] = $OSinfo
                        } # end if VMtoOS
                    
                    # Execute the actual scriptblock command 

                    $Output = Invoke-Command -Session (Get-PSSession -Name $VMe) -ScriptBlock $ScriptBlock
       
                    Write-Host "[$VMe]" -ForegroundColor DarkCyan -NoNewline

                        if (!$Output){$Output = ''}

                        # Add the location and OS when the output is a PSCustomObject and add it to the results array

                        if ($Output.gettype().name -eq 'PSCustomObject')
                        {
                            $Output.PSObject.Properties.Remove('Runspaceid')
                            $Output.PSObject.Properties.Remove('pscomputername')
                            $Output | Format-List
                            $Output | Add-Member -MemberType noteproperty -Name 'Location' -Value $VMtoLoc[$VMe]
                            $Output | Add-Member -MemberType noteproperty -Name 'OS' -Value $VMtoOS[$VMe]
                            $Results += $Output
                        } else {

                            $Result = [pscustomobject]@{
                                VM       = $VMe
                                Result   = $Output
                                Location = $VMtoLoc[$VMe]
                                OS       = $VMtoOS[$VMe]
                            }

                            $Results += $Result
                            $Result | Format-List

                        } # end if Output

                } else {

                  $Errmessages += "Could not locate PSsession for '$VME', please verify connectivity."

               } # end if
             } # end foreach
           } # end if shouldprocess

        } # end process block

          END {

            # Output and order results 

            if ($Results)
            {

                Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan
                $Errmessages
                Write-Host "`n`tOrdered Results" -ForegroundColor Cyan

                $Results |
                Sort DurationinMS,result |
                select * -ExcludeProperty url, httpconnect |
                Format-Table -AutoSize

                # Set results to a global accessible variable for further analysis

                $Global:Results = $Results 

                Write-Host 'Tip: You can use the $Results array variable to sort or expand the results.'

            } # end results

         } # end end block
    } # end function Execute-RemoteCommand

    Function Global:Update-PublicEndpointPort 
    {
        <#
            .SYNOPSIS
            Updates the Azure Public Endpoint port for the given VM's, the endpoint port increments with one for each additional VM.
            .DESCRIPTION
            In case of outside FireWall restrictions prohibiting Azure's upper port ranges, it may be necessary to update the 
            Public WinRM or Public RemoteDesktop TCP port.The EndPointPort parameter is incremented by one for each additional VM.
            This function accepts one or more VM's in an array in the Name parameter,
            the parameter EndPointName as a string and the EndPointPort parameter as an integer.
            .PARAMETER Name
            One or more Virtual Machines to operate against. Accepts pipeline input ByValue and ByPropertyName.
            .PARAMETER EndpointName
            Is mandatory and accepts RemoteDesktop or PowerShell as the endpoint name.
            .PARAMETER EndPointPort
            Is mandatory and accepts the TCP port range 1-65535
            .EXAMPLE
            Select-VM | Update-PublicEndpointPort -EndPointName PowerShell -EndPointPort 5000
            .EXAMPLE
            Update-PublicEndpointPort VM-EA RemoteDesktop 6000
            .LINK
            www.ruudborst.nl
        #>

        [CmdletBinding(SupportsShouldProcess = $True)]
        Param(            
            [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True,HelpMessage='Enter the VM name')] 
            [Alias('ComputerName','MachineName','Server','VM')]   
            [ValidateLength(3,15)]         
            [string[]]$Name,
            [Parameter(HelpMessage = 'Choose RemoteDesktop or PowerShell')]        
            [ValidateSet('RemoteDesktop', 'PowerShell')]    
            [string]$EndpointName="PowerShell",
            [Parameter(HelpMessage = 'Valid port range 1-65535')]    
            [ValidateRange(1,65535)]        
            [int]$EndPointPort= (get-random -Minimum 6000 -Maximum 9000)        
        )  

        BEGIN {
            Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan
        } # end begin block

        PROCESS {

            if ($pscmdlet.ShouldProcess($Name))
            {
                $Name | ForEach -Process {

                    Write-Host "`n[$_ | $($VMtoLoc[$_])]" -ForegroundColor DarkCyan
                    Write-Host "`nUpdating $EndpointName public port to $EndPointPort ..."

                    Try {

                    Get-AzureVM $_ |
                    Set-AzureEndpoint -Name $EndpointName -PublicPort $EndPointPort |
                    Update-AzureVM 

                    if ($VMtoUri[$_] -and $EndpointName -eq "PowerShell"){$VMtoUri[$_] = $VMtoUri[$_] -replace ":[0-9]*$",":$EndPointPort"}
                    if ($VMtoRDP[$_] -and $EndpointName -eq "RemoteDesktop"){$VMtoRDP[$_] = $VMtoRDP[$_] -replace ":[0-9]*$",":$EndPointPort"}
                    $EndPointPort++

                    } catch {

                    write-warning $_.Exception.Message
                    "Failed updating endpoint $EndpointName, make sure the endpoint named '$EndpointName' exists. Use 'New-ExternalEndpoint' to define it."
                    
                    } # end catch
                } # end foreach vm
            } # end shouldprocess
        } # end process block
    
    } # end Update-PublicEndpointPort 

    Function Global:Generate-RDPFile
    {
        <#
            .SYNOPSIS
            Generates a RDP connection file.
            .DESCRIPTION
            Generates the RDP file in the current user's temporary directory. 
            Supply the Directory parameter to save the file in a directory other then the default temporary directory. 
            Supply the NoLaunch switch parameter to skip launching the Remote Desktop connection (mstsc).
            Supply the NoPass switch parameter to save the RDP file without secure password.
            .PARAMETER Name
            One or more Virtual Machines to operate against. Accepts pipeline input ByValue and ByPropertyName.
            .PARAMETER Directory
            Supply the directory for the directory parameter where to save the RDP files in. The file won't be deleted afterwards.
            Leave empty to use the current user's temporary directory retrieved via '$env:TEMP'.
            .PARAMETER NoLaunch
            Supply the NoLaunch switch parameter without any value, this way the remote desktop file won't be launched with mstsc (Remote Desktop connection).
            .PARAMETER NoPass
            Prevents the password being saved into the RDP file as an secure string. By default the function retrieves the password from the
            VMcred PScredential object which was used to set the VM 'administrator' account. This way we are able to logon without any logon prompt.
            .EXAMPLE
            Generate-RDPFile vm-ea
            Generates a RDP file for VM 'VM-EA' in the $env:TEMP temporary directory and deletes the file afterwards.
            .EXAMPLE
            Select-VM | Generate-RDPFile -Directory c:\users\ruudborst\desktop -NoLaunch
            Allows you to select one or more newly created VM's indexed by the script, generate a RDP file in the chosen directory and disable the launch of the RDP connection.
            .LINK
            www.ruudborst.nl
        #>

        [CmdletBinding(SupportsShouldProcess = $True)]
        Param(            
            [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True,HelpMessage='Enter the VM name')] 
            [Alias('ComputerName','MachineName','Server','VM')]   
            [ValidateLength(3,15)]         
            [string[]]$Name,
            [Parameter(HelpMessage = 'Enter the RDP file destination path')]        
            [ValidateScript({if ($_ -match '\\'){Test-Path $_}else{$True}})]
            [string]$Directory,
            [Parameter()]        
            [switch]$NoLaunch,
            [Parameter()]        
            [switch]$NoPass  
        )  

        BEGIN {
            Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan
        }

        PROCESS {

            if ($pscmdlet.ShouldProcess($Name))
            {
                $Name | ForEach -Process {


                    $VMname = $_

                    if (!$VMtoRDP[$VMname])
                    {
                        
                        "Could not find '$VMname' RDP endpoint $vmtorurl in the VMtoRDP hashtable.`n"
                        "Press 'y' to execute the 'Index-VMinfo -All' function and index all VM RDP and WinRM url's from Azure or press any other key to abort.`n"

                        $IndexVMs = Read-Host  -Prompt "Index RDP endpoint url's (y/n)?"

                        if ($IndexVMs -eq 'y') 
                        {
                            Index-VMinfo -All
                            Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

                            if (!$VMtoRDP[$VMname]){
                            "$VMname not found in your Azure subscription."
                            break 
                            } # end if VMtoRDP
                            
                        }
                        else 
                        {
                            break
                        } # end if indexvms

                    } # end if VMtoRDP

                    # Save in specified directory, save in temporary directory and delete afterwards if directory is not specified

                    if ($Directory)
                    {
                        $RDPfilepath = "$Directory\$VMname.rdp"
                    } else {
                        $RDPfilepath = "$env:TEMP\$VMname.rdp"
                    } #end if directory

                    Write-Host "`n[$_ | $($VMtoLoc[$VMname])]" -ForegroundColor DarkCyan
                    "`nGenerating RDP File ...`n"

                    # Sets the username from the VMcred credential and the RDP address retrieved via the 'index-vminfo' function
                    # For Single PowerShell Function Execution Sign On (SPFESO) the authentication level is set to 'no authentication/Connect and don’t warn me'.

                    $Username = $VMcred.UserName
                    set-content $RDPfilepath -Value "full address:s:$($VMtoRDP[$VMname])"
                    add-content $RDPfilepath -Value "username:s:$Username"
                    add-content $RDPfilepath -Value "authentication level:i:0"

                    # If the nopass parameter isn't supplied and VMcred credential is not empty
                    # then save the password from the VMcred credential as an encrypted password in the RDP file

                    if (!$NoPass -and $vmcred){

                     $Ss = $VMcred.password | ConvertFrom-SecureString
                     add-content $RDPfilepath -Value "password 51:b:$Ss"

                         if ($vmtordp[$vmname] -match "(.*):"){
                          $RDPfqdn = $matches[1]
                         } # end if vmtordp
 

                         # Ask for registry write confirmation and write a registry entry in HKCU for Single PowerShell Function Execution Sign On (SPFESO) :)

                         if (!$WriteReg){
                            $Global:WriteReg = read-host -Prompt "In order to avoid the unknown RDP publisher warning and SSO to the Demo VM's it is necessary to set the following reg key for the RDP client: 'HKCU:\Software\Microsoft\Terminal Server Client\LocalDevices\VMname' to DWORD decimal value 76. This is the 'don't ask me again' tick box setting when you launch a RDP connection. Make it SSO (y/n)?" 
                         } # end writereg
                    
                         # Adding the reg key to bypass the RDP client 'unkown publisher' warning for SPFESO purposes

                         if ($Writereg -eq 'y'){

                           $RegPath = 'HKCU:\Software\Microsoft\Terminal Server Client\LocalDevices'

                            if (!(Test-Path $RegPath)){
                              New-Item $RegPath -Force
                            } # end if RegPath

                            Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Terminal Server Client\LocalDevices' -Name $RDPfqdn -Value 76 -type dword -Force

                         } # end writereg y

                     "`nFile '$RDPfilepath' generated with saved encrypted credentials."

                    } else {

                     "`nFile '$RDPfilepath' generated without saved credentials."

                    } # end if nopass,vmcred

                    # Launch Remote Desktop connection if the nolaunch parameter isn't specified

                    if (!$NoLaunch){
                        mstsc $RDPfilepath
                    } # end if NoLaunch

                    # Deletes the RDP file when the tempory location is used and otherwise warn if the RDP file with password is saved in a given directory.

                    if (!$Directory){

                     write-host "Temporary location used, deleting RDP file  ..." -NoNewline
                     sleep 2

                         try {

                         del $RDPfilepath -Force -Confirm:$False

                         } catch {

                         "Failed to delete the $RDPfilepath file, please delete the file manually."
                         break

                         } # end Try/Catch

                     " deleted '$RDPfilepath'." 

                     } elseif (!$NoPass -and $vmcred) {

                     "`n"
                     write-warning "Added password as a secure string in the RDP file for direct logon demo purposes. If you don't want to save the password (possible decryption) then use the '-NoPass' parameter."

                     } # end if directory/nopass/vmcred

                } # end foreach VMs
            } # end shouldprocess
        } # end process block
    } # end function Generate-RDPFile

    Function Global:Delete-AzureVM 
    {
        <#
            .SYNOPSIS
            Deletes one or more VM's.
            .DESCRIPTION
            Deletes the VM and related services from Azure.
            .PARAMETER Name
            One or more Virtual Machines to operate against. Accepts pipeline input ByValue and ByPropertyName.
            .EXAMPLE
            Delete-AzureVM -Retrieve
            Executes the slow query with 'Get-AzureVM' to retrieve all VM's live from Azure instead of using the indexed ones created with this script.
            .EXAMPLE
            Select-VM | Delete-AzureVM
            Allows you to select and delete the VM's created by this script.
            .LINK
            www.ruudborst.nl
        #>

        [CmdletBinding(DefaultParametersetName="2",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
        Param(
            [Parameter(ParameterSetName = "1",ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True,ValueFromRemainingArguments=$true,HelpMessage='Enter the VM name')] 
            [Alias('ComputerName','MachineName','Server','VM')]   
            [ValidateLength(3,15)]         
            [string[]]$Name,
            [Parameter(ParameterSetName = "2",HelpMessage = "Specify parameter as a switch to retrieve the VM's from Azure")]
            [Switch]$Retrieve
        )  
        
        BEGIN {

                Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

                Write-Host "This function deletes the VM, related services and attached disks for the virtual machines specified. You will receive a delete confirmation request for each Virtual Machine.`n"
                
                Pause

                # Create the removevms array to store the deleted VM's in an array and process them in the END block

                $RemovedVMs = @()

                # Instantiate the VM to Location Hash table if it doesn't exist

                if (!$VMtoLoc){$Global:VMtoLoc = @{}}

        } # end begin block


        PROCESS {

            # Warn and break if no VM name or retrieve parameter is specified

            if (!$Name -and !$Retrieve) {

                "`n";Write-Warning -Message "No input received for the Name parameter, please specify the '-Retrieve' parameter to retrieve the VM's from Azure and delete the selected ones."
                break

            # Else if name is not specified but retrieve is then execute get-azurevm to retrieve a list to choose from

            } elseif (!$Name -and $Retrieve)  {

                Write-Host "`nRetrieve parameter specified, retrieving VM's from Azure using 'Get-AzureVM' ..."
                $VMs=(Get-AzureVM).Name

                if ($VMs) {

                    try {
                    $Name = $VMs | Out-GridView -Title "Please select one or more VM's for deletion" -PassThru
                    }catch{
                    # do nothing
                    } # end try/catch

                } else {

                    "`nNo VM's found in Azure, try to create a VM by running this script again or use the function, for example: 'Create-AzureVM VM1'."
                    break

                } # end if

                if (!$Name) {

                    "No VM's selected, exiting function ..."
                    break

               } # end if name

            } # end if name,retrieve


            if ($pscmdlet.ShouldProcess($Name)) {

                if ($Name){
                       
                        # Delete the VM, Azure Service and DISK/VHD. Add the VM to the RemovedVMs array for processing in the END block

                        $Name | ForEach {

                            Write-Host "`n[$_ | $($VMtoLoc[$_])]`n" -ForegroundColor DarkCyan
                            Get-AzureVM $_ | Remove-AzureVM -DeleteVHD:$True -verbose
                            Remove-AzureService -ServiceName $_ -force:$True -Verbose
                            $RemovedVMs += $_

                        } # end foreach azurevm

                 } # end if Name

            } # end shouldprocess

        } # end process block

        END {

            # Removes the VM from all VM info hashtables

            $RemovedVMs | % {

                try{$VMtoLoc.remove($_)}catch{}
                try{$VMtoUri.remove($_)}catch{}
                try{$VMtoRDP.remove($_)}catch{}
                try{$VMtoIP.remove($_)}catch{}
                try{$WinRMFwInfo.remove($_)}catch{}

            } # end foreach

        } # end end block
    
    } # end Delete-AzureVM function

    Function Global:Delete-AzureStorageAccount
    {
        <#
            .SYNOPSIS
            Deletes one or more storage accounts.
            .DESCRIPTION
            Deletes the empty storage account in Azure.
            .PARAMETER Name
            This is the fully written Storage Account Name, accepts pipeline input ByValue and ByPropertyName.
            .EXAMPLE
            Delete-AzureStorageAccount -Retrieve
            .EXAMPLE
            Delete-AzureStorageAccount stornorthcentralus
            .LINK
            www.ruudborst.nl
        #>

        [CmdletBinding(DefaultParametersetName="2",SupportsShouldProcess = $True, ConfirmImpact = 'High')]
        Param(            
            [Parameter(ParameterSetName = "1",ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True,ValueFromRemainingArguments=$true,HelpMessage = 'Enter the storage account name')] 
            [Alias('StorageAccount')]  
            [ValidateLength(3,24)]
            [ValidateScript({$_ -cmatch "^[a-z0-9]*$"})]          
            [string[]]$Name,
            [Parameter(ParameterSetName = "2",HelpMessage = 'Specify to retrieve the storage accounts from Azure')]
            [Switch]$Retrieve
        )  

        BEGIN {
                Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

                "This function deletes empty storage accounts, make sure there is no data in the account otherwise the deletion will fail."
                Pause
              
              
                # Create the RemovedSTa array to store the deleted storage accounts in an array and process them in the END block

                $RemovedSTa = @()

        } # end begin block

        PROCESS {

            # Warn and break if no Storage account name or retrieve parameter is specified

            if (!$Name -and !$Retrieve) {

                "`n";Write-Warning -Message "No input received for the name parameter, please specify a storage account name or use the '-Retrieve' parameter to retrieve the Storage Account's from Azure and select the ones you want to delete."
                break

            # Else if name is not specified but retrieve is then execute Get-AzureStorageAccount to retrieve a list to choose from
            
            } elseif (!$Name -and $Retrieve) {
                write-host "`nRetrieve parameter specified, retrieving accounts from Azure ..."
                $Name = (Get-AzureStorageAccount -WarningAction SilentlyContinue |
                    select StorageAccountName, Label, GeoPrimaryLocation |
                Out-GridView -Title 'Please select one or more storage accounts to delete' -PassThru).StorageAccountName

                if (!$Name) 
                {
                    write-host "No Storage Account's selected, aborting function ...`n"
                    break
                } # end if StorageAccountName

            } # end if StorageAccountName,Retrieve

            if ($pscmdlet.ShouldProcess($Name))
            {
                if ($Name){

                    # Delete the storage account and add the account to the RemovedSTa array for processing in the END block

                    $Name | ForEach -Process {

                        Write-Host "`n[$_]`n" -ForegroundColor DarkCyan

                        try {

                        Remove-AzureStorageAccount -StorageAccountName $_ -ErrorAction Stop -Verbose
                        $RemovedSTa += $_
                        
                        } catch {

                        write-warning $_.exception.message
                        write-warning 'Could not delete storageaccount, make sure the account is empty or wait for Azure to remove the VM files from the account and try again.'
                        
                        } # end catch

                    } # end foreach Name

                 } # end if Name

            } # end shouldprocess

        } # end process block

        END {

          # Removes the Storage Account from the storage account to location hashtable    

          $RemovedSTa | ForEach -Process {
        
            try{
             $STtoLoc.remove($_)
            }catch{
             # do nothing
            } # end try/catch

           } # end foreach RemovedSTa

        } # end end block

    } # end Delete-AzureStorageAccount function

    Function Global:Select-VM 
    {
        <#
            .SYNOPSIS
            Select on or more script indexed Azure VM's.
            .DESCRIPTION
            Allows you to select one or more newly created VM's by this script 
            and select their names via the out-gridview cmdlet and output them as an array.
            All VM's are returned by supplying the 'All' parameter. 
            .PARAMETER All
            Returns all VM's as an array instead of selecting them in a gridview.
            .EXAMPLE
            Select-VM
            .EXAMPLE
            Select-VM | Delete-AzureVM
            .EXAMPLE
            Select-VM -All | Execute-RemoteCommand
            .EXAMPLE
            Execute-RemoteCommand (Select-VM)
            .LINK
            www.ruudborst.nl
        #>

        Param([switch]$All)

        # Returns all indexed VM's as an array when the All parameter is supplied
        # Else if the parameter isn't specified let the user select one or more indexed VM's
        # Else if their are no indexed VM's (not created in this session) let the user choose to execute the index-vminfo and retrieve all VM's from Azure 

        if ($VMtoLoc.count -gt 0 -and $All) {
          [array]$VMarray = $VMtoLoc.keys
          $VMarray 
        } elseif ($VMtoLoc.count -gt 0) {
            ($VMtoLoc | Out-GridView -PassThru -Title 'Select VM').name
        } else {

            Write-Host "`n - [$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan
            write-Host "No VM's indexed, executing 'Index-VMinfo -All' to index all available VM's in Azure.`n"
            Index-VMinfo -All
            Select-VM

        } # end if VMtoLoc

    } # end function select-vm

    Function Global:Pause 
    {
        $Message = "`nPress any key to continue ..."

        # Determine if we're running the Console or ISE, ISE gives an error if you use the $host.UI.RawUI.ReadKey method

        if ($Host.name -eq 'ConsoleHost')
        {
            $Message
            $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown') 
        }else
        {
            $null = Read-Host -Prompt $Message
        } # end if

    } # end pause function

    #
    # Scriptblocks
    ##

    # Performs a .NET webclient HTTP connect to google and measures the response.
    # This scriptblock is used as the default scriptblock in the 'execute-remotecommand' function. 

    $Global:HttpConnect = {

        if (!$webclient)
        {
            # Change to your url

            $url = 'http://www.google.com'
            $webclient = New-Object System.Net.WebCLient
            $hostname = $env:COMPUTERNAME
        } # end if webclient check

        $IPaddreses = (Get-WmiObject -Class Win32_NetworkAdapterConfiguration).ipaddress
        $IP = ($IPaddreses | Where{
                $_ -match '\d'
            }
        )[0]

        $MS = [math]::round((Measure-Command -Expression {
                    $Result = $webclient.DownloadString($url)
                }
        ).totalmilliseconds,2)

        if ($Result -match 'google'){

            [pscustomobject]@{
                VM           = $hostname
                Url          = $url
                HttpConnect  = 'Success'
                DurationinMS = $MS
            }

        } else {

            [pscustomobject]@{
                VM                  = $hostname
                URL                 = $url
                HttpConnect         = 'Failed'
                ConnectDurationinMS = $null
            }

        } # end if result

    } # end httpconnect scriptblock

    # Retrieves the VM Hyper-V through the default integration services set values

    $Global:HyperVHost = {(Get-Item "HKLM:\SOFTWARE\Microsoft\Virtual Machine\Guest\Parameters").GetValue("HostName")}

    #
    # Workflows
    ##

    # These workflows are used in the main routine and aid in the batch creation of the VM's and storageaccounts by creating parallel PS workflow threads/runspaces

    Workflow WFCreate-StorageAccounts {
        
        param($StorageAccounts)

        foreach -parallel($StorageAccount in $StorageAccounts.keys)
        {
            Create-AzureStorageAccount -StorageAccountName $StorageAccount -Location  $StorageAccounts[$StorageAccount]
        } # end foreach AzureVMS parallel
    } # end WFCreate-StorageAccounts

    Workflow WFCreate-AzureVMs {
        
        param($AzureVMS,$VMcred,$ImageName,$InstanceSize)

        foreach -parallel($AzureVM in $AzureVMS.keys) {

        # Built-in sleep, this we way PS workflow doesn't run into the dreadful AzureProfile.json being used by another process
        # when switching the storage account in the active subscription, the change happens in the profile file which can't be accessed by multiple processes/threads.

        $WaitDelay = 400
        $Index = [array]::indexof($AzureVMS.keys,$AzureVM)

            if ($Index -in 0..4){
             $SleepinMS = $Index * $WaitDelay
            } elseif ($Index -in 5..9) {
             $SleepinMS = ($Index - 5) * $WaitDelay
            } elseif ($Index -in 10..15) {
             $SleepinMS = ($Index - 10) * $WaitDelay
            } # end if Index

        Create-AzureVM -VM $AzureVM -StorageAccountName  $AzureVMS[$AzureVM] -Credential $VMcred -ImageName $ImageName -InstanceSize $InstanceSize -SleepinMS $SleepinMS

        } # end foreach AzureVMS parallel

    } # end WFCreate-AzureVMs


} # end main begin block

PROCESS {

    #
    # Main routine
    ##

    Write-Host "`n[$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

    "This script provisions an Azure VM, Azure Service and tied Storage Account in each available Microsoft Azure Region.`nUse 'Get-Help $($myinvocation.MyCommand) -Full' for more information or visit the blog post on http://www.ruudborst.nl"

    # Scoping instancesize to global for reuse in 'Create-AzureVM' when breaking the script at this point.
    
    $Global:InstanceSize = $InstanceSize

    # Wait for user consent by pressing any key and start collecting input

    Pause ; Sleep 1

    # Create a splat and adds the script parameter to use in the ConnectTo-Azure function, it selects a existing subscription or imports a new subscription. 
    # The importpubfile parameter uses the import certificate publish file method 'Import-AzurePublishSettingsFile',
    # it overcomes the 12 hour expiring session of the default script chosen 'add-azureaccount' method.

    $Null = $PSBoundParameters.remove("VMPrefix")
    $Null = $PSBoundParameters.remove("StorageAccountPrefix")
    $Null = $PSBoundParameters.remove("InstanceSize")

    ConnectTo-Azure @PSBoundParameters

    Write-Host "[$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

    # Retrieves the available deployment images from Azure and their respective image family's.
    # It selects the latest image for the chosen image family and stores it in the ImageName variable. 
    
    Write-Host " - [Retrieve-Image]`n" -ForegroundColor Cyan

    Write-Host "Retrieving Azure VM images ...`n"
     
    $null = Retrieve-Image

    Write-Host "Found image '$ImageName'"
    Sleep 1

    Write-Host "`n[$($myinvocation.MyCommand)]" -ForegroundColor Cyan

    # Prompts for the Datacenter locations where the VM should be deployed, locations are retrieved via the ConnectTo-Azure function

    $ChosenLocations = $Locations | Out-GridView -PassThru -Title "Select Azure regions. A VM and Storage Account will be created in each region."
    write-host "`nUsing the chosen regions: " -NoNewline
    write-host $ChosenLocations -ForegroundColor DarkCyan -Separator ", " -NoNewline ;'.'

    # Prompts for the Azure VM Windows credential, username 'Administrator' or 'Admin' is prohibited.

    $Global:VMcred = Get-Credential -UserName "AzureAdmin" -Message "Please supply a Windows administrator account username and complex password.`n Username 'Administrator' or 'Admin' is prohibited."
    
    if ($VMcred.username -eq 'Administrator' -or $VMcred.username -eq 'Admin') 
    { 
        Write-Host 'Username Administrator or Admin is prohibited, please choose another username.'
        Pause
        $Global:VMcred = Get-Credential -Message "Please supply the Azure Virtual Machine Windows Admin`n username and password." 

    } # end if $VMcred.username check

    # Regex password check matched with Azure's password policy, reprompt user for password when it doesn't match.

    if ($VMcred.GetNetworkCredential().Password -notmatch "^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,30}$") 
    { 
        write-warning 'Password does not meet complexity requirements. Password must be at least 8 characters in length and must contain one UPPER case character, one lower case character and one number.'
        Pause
        $Global:VMcred = Get-Credential -UserName $VMcred.username -Message "Please supply a complex password witn a minimum length of 8 characters." 

    } # end if VMcred.password check

    # VMprefix combined with the Azure location/region short name forms the unique Azure DNS name of the VM.
    # Since it has to be unique, get-random is used when the VMprefix is blank.

    $Rand = (Get-Random -Minimum 100 -Maximum 999)

    if (!$VMprefix) 
    {
        $VMprefix = "DEMO$Rand-"
    } # end if VMprefix

    # StorageAccountPrefix combined with the location short name forms the unique Azure DNS name of the StorageAccount.
    # Since it has to be unique, get-random is used when the StorageAccountPrefix is left empty.

    if (!$StorageAccountPrefix) 
    {
        $StorageAccountPrefix = "demo$Rand"
    } # end if StorageAccountPrefix

    # Generating VM and storage account names combined with the chosen locations and prefixes.
    # All data is stored in hashtables and used in the workflow execution below.

    if ($ChosenLocations -and $VMcred -and $ImageName ) {

        # Create the provisioning hashtables

        $VMsCount = 0
        $Global:StorageAccounts = @{}
        $Global:AzureVMs = @{}

        # The foreach combines each chosen location with the relevant 
        # unique prefix to form the short VM name and long lowercase 
        # storage account name and stores them in the provisioning hashtables.

        $ChosenLocations | ForEach -Process {

            # Sets VM name based on the location without any spaces in it
            $Location = $_
            $Name = $Location -replace ' ', ''
            $VMname = $null

            $Location -split ' ' | ForEach -Process {
                $VMname += $_.substring(0,1)
            } # end foreach

            $VMname = $VMprefix + $VMname
            $StorageAccountName = ($StorageAccountPrefix + $Name).tolower()

            # Add storage account name,vm and location to the provisioning 
            # hashtables used by the create 'WFCreate-StorageAccounts' and 'WFCreate-AzureVMs' workflows

            $StorageAccounts[$StorageAccountName] = $Location
            $AzureVMS[$VMname] = $StorageAccountName

          } # end foreach chosenlocations 

        'Generated configuration data.'

        $CreationStart = Get-Date

        # Executing the creation of the storage accounts and related VM's through PowerShell's parallel workflow execution.
        # Parallel workflow execution in PS version 3 is restricted to five threads, for more information see script description.

        Write-Host "`n - [WFCreate-StorageAccounts]`n" -ForegroundColor Cyan

        "Starting storage account creation through PowerShell's parallel workflow execution ...`n"

        WFCreate-StorageAccounts $StorageAccounts

        Write-Host "`n - [WFCreate-AzureVMs]`n" -ForegroundColor Cyan

        "Starting VM creation through PowerShell's parallel workflow execution ...`n"

        WFCreate-AzureVMs $AzureVMS $VMcred $ImageName $InstanceSize

        $CreationEnd = Get-Date

    } else {
        Write-Warning -Message 'Please make sure you supplied the Datacenter location, VM credentials and image family type, exiting ...'
    } # end if chosenlocations,vmcred,image

   
} # end process block


END {
       
        # Scoping the script variables to the global scope for script/console re-use purposes

        $Global:VMprefix = $VMprefix
        $Global:StorageAccountprefix = $StorageAccountprefix
        $Global:SubscriptionName = $SubscriptionName

        # Index the created VM's with WinRM Endpoint information.
        # WinRM endpoint information is needed for Remote PowerShell commands which are executed via the 'Execute-RemoteCommand' function,
        # which in turn calls the 'Session-Setup' function and requires the WinRM url to establish the remote PS session through SSL.

        Index-VMinfo -NoInfo

        # Checking the successful creation of the VM's and StorageAccounts by querying Azure since we can't get any variables from the workflows
        
        [array]$AzureVMs.keys | foreach {
        
            if (!$VMtoLoc[$_]){
                $AzureVMs.remove($_)
            } # end if VMtoLoc

         } # end foreach AzureVMS

        [array]$StorageAccounts.keys | foreach {

            if (!$STtoLoc[$_]){
                $StorageAccounts.remove($_)
            } # end if STtoLoc
            
         } # end foreach StorageAccounts

        Write-Host "`n[$($myinvocation.MyCommand)]`n" -ForegroundColor Cyan

        # Outputs the creation duration and VM count.

        $VMcreatedCount = $AzureVMs.count

        # Output the created VM's and Storage Accounts plus script examples and functions to use through 'get-help', that's all folks!

        if ($VMcreatedCount -ge 1){

            $CreationDuration = [System.Math]::Round(($CreationEnd - $CreationStart).TotalMinutes, 2)

            write-host "Created $VMcreatedCount Azure VM's and tied Storage Accounts in " -NoNewline
            write-host "$CreationDuration minutes." -ForegroundColor Green 

            $AzureVMS.keys | select @{Name="VM";Expression={$_}},@{Name="Location";Expression={$StorageAccounts[$AzureVMS[$_]]}},@{Name="StorageAccount";Expression={$AzureVMS[$_]}} | Format-Table 
            Pause

            write-host "`nUse the imported script functions below to manage the VM's. For more information about a specific function use 'Get-Help FunctionName -Full'."
        
            # Retrieve all script functions matching the unique link with 'Get-Help' and output the name and description

            $FunctionHelp = get-help -Category Function | ? {$_.relatedlinks -match "www.ruudborst.nl"} 
            $FunctionHelp | sort name| ft @{Name="Function";Expression={$_.name}},Synopsis,@{Name="Example";Expression={$_.examples.example.code[0]}} -AutoSize
            
            # Displaying some examples, 'write-host' needed for nonewline and coloring purposes, don't shoot me :)

            write-host 'Example: ' -NoNewline
            write-host 'Select-VM | Execute-RemoteCommand' -ForegroundColor DarkCyan
            write-host 'Example: ' -NoNewline
            write-host 'Select-VM -All | Execute-RemoteCommand -sb {(measure-command {iwr ams-ix.net -usebasicparsing}).totalseconds}' -ForegroundColor darkcyan 
            write-host 'Example: ' -NoNewline
            write-host 'Generate-RDPFile (Select-VM)'  -ForegroundColor darkcyan 
            write-host 'Example: ' -NoNewline
            write-host 'Select-VM | Generate-RDPFile -Directory ''c:\RDPfiles'' -NoLaunch'  -ForegroundColor darkcyan 
            write-host 'Example: ' -NoNewline
            write-host '@(''UniqueVMname1'',''UniqueVMname2'') | Create-AzureVM' -ForegroundColor darkcyan 
            write-host 'Example: ' -NoNewline
            write-host 'Cleanup-Demo' -ForegroundColor darkcyan 

        } # end if VMcreatedCount

} # end end block